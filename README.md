# <p align="center">⚽Plrecipe📜</p>

<p align="center"></p>

<img src="https://github.com/6candoit/Plrecipe/blob/dcaa869a0aade778eacd60230df05a55439c1a33/PNG/plrecipe_Logo(%EC%9E%84%EC%8B%9C).png">

 `Plrecipe`는 "놀다"를 의미하는 `Play`와 "요리법"을 의미하는 `Recipe`의 합성어로, <strong><em>사용자에게 다양한 놀거리를 제공하는 서비스</em></strong>입니다. 사용자는 음식점, 카페, 산책, 액티비티 등을 조합하여 자신만의 코스를 만들 수 있으며, 이를 기반으로 게시글을 작성하여 다른 회원들과 공유할 수 있습니다. 또한 사용자는 그룹을 생성하여 혼자 또는 친구들과 함께 게시물을 공유하고 추억을 쌓을 수 있습니다. 

### 🙌🏻 팀명 : 6CanDoIt!

### 😁 팀원

<div align="center">
 
|<img src="https://github.com/6candoit/Plrecipe/blob/abe45853ca17dede0881dbf0212ea25d74834bac/PNG/cow1.png" height="100">|<img src="https://github.com/6candoit/Plrecipe/blob/abe45853ca17dede0881dbf0212ea25d74834bac/PNG/tiger.png" height="100">|<img src="https://github.com/6candoit/Plrecipe/blob/abe45853ca17dede0881dbf0212ea25d74834bac/PNG/bunny.png" height="100">|<img src="https://github.com/6candoit/Plrecipe/blob/abe45853ca17dede0881dbf0212ea25d74834bac/PNG/dragon.png" height="100">|<img src="https://github.com/6candoit/Plrecipe/blob/abe45853ca17dede0881dbf0212ea25d74834bac/PNG/cow2.png" height="100">|
|:---:|:---:|:---:|:---:|:---:|
| [배성민](https://github.com/mini-xi) | [한소혜](https://github.com/Sosohy) | [윤재은](https://github.com/yunjaeeun) | [조수빈](https://github.com/chosoobin37) | [김재현](https://github.com/jaehyeon-SMU) |
</div>

## 📝 프로젝트 개요

### 1. 프로젝트 소개
<br/>
&nbsp;저희 프로젝트는 '플레시피'라는 이름으로, JAVA Spring, MyBatis, JPA, 외부 API를 활용하여 백엔드를 구현하고, 프론트엔드까지 구현하는 것을 목표로 하고 있습니다. 이 프로젝트는 구체적이고 기능의 고도화보다는 학습한 내용을 기반으로 주요 기능 중 구현 가능한 기능을 우선적으로 구현하여 진행되었습니다.

&nbsp;`'플레시피'` 서비스는 사용자가 원하는 장소를 조합하여 자신만의 코스를 만들고, 이를 게시글 형식으로 다른 사용자들과 공유할 수 있는 기능을 제공합니다. 또한, 사용자들은 회원끼리 모인 그룹 또는 혼자만의 그룹을 생성하여 추억을 저장할 수 있습니다.

&nbsp;이를 통해 사용자들은 자신의 여행이나 취향에 맞는 장소들을 조합하여 특별한 코스를 만들고, 이를 다른 사용자들과 공유하거나 추억을 남기는 등의 활동을 즐길 수 있습니다. 해당 프로젝트는 기능의 확장성을 고려하여 프론트엔드까지 구현하여 사용자들이 보다 편리하게 서비스를 이용할 수 있도록 할 것입니다.  
<br/>
<br/>
  
### 2. 프로젝트 필요성
<br/>
<div align="center">
<figure class="half">
 <a href="link"><img src="https://github.com/6candoit/Plrecipe/blob/6df6df5c68a2f455fa2c00be59c41d229cd051c6/PNG/여행자비율통계.png" height=175></a>
 <a href="link"><img src="https://github.com/6candoit/Plrecipe/blob/6df6df5c68a2f455fa2c00be59c41d229cd051c6/PNG/레저시설이용률통계.png" height=175></a>
</figure>
<br/>
</div>

&nbsp;위의 자료는 2021년까지의 여행자 비율과 레저시설 이용률에 대한 통계를 보여주고 있습니다. 그래프를 통해 하락하는 모습을 확인할 수 있는데, 이는 COVID-19의 영향으로 인한 것입니다. 이로 인해 자유로운 여행이나 활동이 제한되었고, 이는 여행자 비율과 레저시설 이용률에 영향을 주었습니다.

&nbsp;하지만 현재 COVID-19이 종식되면서, 사람들은 그 동안 하지 못한 여행이나 레저 활동을 즐기려는 움직임이 나타나고 있습니다. 종식된 지 약 1년이 지난 지금, 많은 사람들이 친구들과의 추억을 쌓거나 스트레스를 해소하고자 하는 욕구가 커지고 있습니다.

&nbsp;이러한 경향은 향후 여행 업계 및 레저 산업에 긍정적인 영향을 미칠 것으로 예상됩니다. 종식된 COVID-19으로 인한 제약이 풀리면서 사람들의 여행과 레저 활동에 대한 수요가 증가할 것으로 예상되며, 이는 관련 산업의 회복과 성장을 도모할 것으로 전망됩니다.

&nbsp;아래는 이러한 경향을 보여주는 자료 예시입니다.
<br/>

<div align="center">
<figure class="half">
 <a href="link"><img src="https://github.com/6candoit/Plrecipe/blob/6df6df5c68a2f455fa2c00be59c41d229cd051c6/PNG/내국인출국자통계.png" height=145></a>
 <a href="link"><img src="https://github.com/6candoit/Plrecipe/blob/6df6df5c68a2f455fa2c00be59c41d229cd051c6/PNG/1인평균국내여행일수통계.png" height=145></a>
</figure>
</div>

<br/>
&nbsp;위의 그래프는 2021년 이후로 해외로 출국하는 사람과 국내 여행 일수가 늘어나는 여행자 수가 다시 상승하는 추세를 보여주고 있습니다. 이러한 변화된 여행 환경에 적응하며 여행을 다시 시작하는 사람들은 새로운 여행지를 고민하거나 다른 사람의 여행이나 놀거리에 대한 궁금증을 가질 수 있습니다.
<br/>
<br/>
&nbsp;저희 프로젝트는 이러한 사용자들의 고민을 해소하고, 사용자의 추억을 공유하고 저장하는 공간을 제공하기 위해 기획되었습니다. 여행을 또는 놀이를 계획하기 전에는 두근거리는 마음으로 새로운 여행지를 고민하고, 여행이나 즐거운 시간의 여운을 남기며 즐기는 것을 돕고자 합니다.  
<br/> 
<br/>
&nbsp;프로젝트를 통해 사용자들은 여행이나 놀이를 즐기는 동안 추억을 저장하고 나누며, 개인의 행복한 시간을 두 배로 늘릴 수 있는 경험을 제공받게 될 것입니다. 이를 통해 여행에 대한 즐거움을 더욱 풍요롭게 누릴 수 있을 것으로 기대됩니다.
<br/>
<br/>
</aside>

### 3. 프로젝트 주요 기능

<em><ins><strong>1. 코스 생성</strong></ins></em> :  
회원은 자신이 원하는 장소들을 조합하여 놀거리 코스를 생성할 수 있습니다.

<em><ins><strong>2. 그룹</strong></ins></em> :  
회원은 함께하는 그룹을 생성하여, 그룹 내에서 코스를 공유하고 저장할 수 있습니다. 또한, 개인 그룹을 생성하여 혼자서도 코스를 관리할 수 있습니다.

<em><ins><strong>3. 게시글</strong></ins></em> :  
회원은 게시글 형식으로 자신의 코스를 다른 사용자와 공유할 수 있으며, 다른 사용자가 올린 코스도 조회할 수 있습니다.
   
<em><ins><strong>4. 팔로우</strong></ins></em> :  
회원은 다른 회원을 팔로우하여 그 회원이 올린 게시글을 조회하거나 관계를 형성할 수 있습니다.
<br/>
<br/>

## 기술스택
<div align="center">

|DA#|Ubuntu|MariaDB|Java|JavaSpring|MyBatis|JPA|
|---|---|---|---|---|---|---|
|<img src="https://github.com/beyond-sw-camp/be04-1st-4goda-vite/blob/main/PNG/Readme/da%23.png" height="100" />|<img src="https://github.com/beyond-sw-camp/be04-1st-4goda-vite/blob/main/PNG/Readme/ubuntu.png" height="100" />|<img src="https://github.com/beyond-sw-camp/be04-1st-4goda-vite/blob/main/PNG/Readme/mariadb.png" height="100" />|<img src="https://github.com/6candoit/Plrecipe/blob/f48babc85d68e3a266a609d889c41d26433944c6/PNG/java.png" height="100">|<img src="https://github.com/6candoit/Plrecipe/blob/f48babc85d68e3a266a609d889c41d26433944c6/PNG/javaspring.png" height="100">|<img src="https://github.com/6candoit/Plrecipe/blob/f48babc85d68e3a266a609d889c41d26433944c6/PNG/mybatis.png" height="100">|<img src="https://github.com/6candoit/Plrecipe/blob/f48babc85d68e3a266a609d889c41d26433944c6/PNG/jpa.png" height="100">|   

</div>

## WBS

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/3431f2808430514cfcd53cde0d556e64828373a8/PNG/wbs.png" height=600>
</div>

<div align="right">
 
[WBS](https://docs.google.com/spreadsheets/d/1dhRdFafID_h05nar4hWZGUSe7SvHYnjZY0G2BIQMQTE/edit#gid=1108790350)
</div>

## 요구사항
<details>
<summary><b>Plrecipe 상세정책</b></summary>

- **게시글**
    
    - 게시글에는 (1개 이상의 장소를 담은) 코스가 필수로 포함되어야 한다.
    - 게시글 내용은 0글자 이상 작성되어야 한다.(내용 필수 아님)
    - 게시글 이미지는 0개 이상 포함될 수 있다.(이미지 필수 아님)
    - 게시글은 공개/비공개 설정이 가능하다.
        - 그룹 게시물의 경우
            - 공개 -> 모든 사람에게 공개 및 그룹에 추가
            - 비공개 -> 그룹에게만 공개
    - 게시글 수정은 게시글을 작성한 회원/(그룹 게시물의 경우)그룹원만 가능하다.
    - 게시글 삭제는 게시글을 작성한 회원/(그룹 게시물의 경우)그룹원/관리자만 가능하다.
    - 게시글 삭제의 경우 실제 DB에서 삭제되지 않고 삭제 일자가 업데이트 된다.
        
        -> 삭제 일자가 업데이트 된 게시글은 페이지에서 보이지 않는다.
        
- **해시태그**
    
    - 게시글에는 해시태그가 0개 이상 등록되어야 한다.(해시태그 필수 아님)
    - 이미 저장된 해시태그 중 원하는 태그가 없을 경우, 태그를 회원이 직접 등록할 수도 있다.
    - 게시글의 해시태그는 10개까지 등록 가능하다.

- **회원**
  
  - 회원의 ID는 이메일 형식으로 중복될 수 없다.
  - 회원의 비밀번호는 영어와 숫자를 같이 써야 하고 15자를 넘길 수 없다.
  - 회원의 닉네임은 중복 불가능하다.
  - 회원의 닉네임은 부적절한 닉네임일시 제재를 받을 수 있다.
  - 회원등급은 일반회원과 관리자로 구분된다.
  - 회원상태는 활성화/비활성화(임시정지, 영구정지)로 구분된다.
  - 회원상태가 임시정지/비활성화일 경우에는 일반적인 기능 사용이 제한 되고 고객센터만 사용 가능하다.
  - 회원이 탈퇴할 시에도 정보는 데이터베이스에 저장되어 있다.
  - 전화번호는 반드시 기입해야 한다.
  - 회원은 팔로우, 팔로워를 갖는다.
  - 팔로워는 팔로우 하는 대상의 공개된 정보를 열람할 수 있다(회원이 속한 그룹, 회원이 작성한 게시물, 회원 닉네임)
        
- **그룹**

  - 그룹은 처음에 생성될 때 본인만 포함되어 있는(1인) 그룹이 생성된다.
  -그룹에 다른 회원을 초대할 시 회원ID로 초대한다.
  - 그룹 이름을 따로 설정하지 않을 시 "(그룹을 생성한 회원 닉네임)의 그룹"으로 표시된다.
  - 그룹에 구성원을 초대 했을 때 '초대 수락' 후에 그룹에 포함된다.
  - 회원(본인)이 속한 그룹을 공개/비공개로 처리할 수 있다.
  - 회원(본인)은 그룹을 (상단)고정할 수 있다.
  - 그룹원은 (그룹 내 게시글 등록, 본인이 쓴 게시글 삭제, 게시글 수정(본인 포함 그룹원), 그룹 탈퇴, 그룹 내 게시글 댓글 작성) 권한을 갖는다.
  - 그룹장은 그룹원의 권한을 포함해 그룹원 추방, 그룹 이름 수정, 그룹원 초대 권한, 그룹 공개 여부 권한, 그룹장 위임을 갖는다.
  - 그룹장이 그룹을 탈퇴한 경우 두 번째로 그룹에 포함된 사람이 그룹장이 된다.
  - 이미 초대한 그룹원이 수락 또는 거절을 하기 전(대기 중)인 경우, 재초대가 불가능하다.

- **코스**
  
    - 중복된 장소는 코스에 등록할 수 없음.
    - 코스 블럭은  장소 카테고리별로 색깔이 매겨짐.
    - 코스는 상단부터 쌓이고 갔던 장소는 재 방문 불가능
    - 장소 데이터베이스에 존재하지 않으면 코스 작성하는 도중에 사용자가 장소 등록 가능
    - 코스 만들고 사용자가 코스 이름 붙일 수 있음
   
- **장소**

    - 장소 카테고리(음식점, 카페, 문화, 액티비티, 산책, 기타)
    - 외부 API에서 받아온 장소를 사용자가 적절한 카테고리를 붙여 장소 등록
    - 장소 등록시 카테고리를 무조건 붙여야 함.
    - 장소를 등록하기 전에 동일한 주소 또는 이름으로 이미 등록되어 있는 정보를 사용자에게 한번 확인 시키고 등록하는 절차로 진행(동일한 주소, 이름이 없는 경우 확인하지 않음)
    - 장소 별점을 남길 때 간단한 한 줄 코멘트 작성 가능 (별점은 1 ~ 5개)
    
</details>

## DDD(Event-Storming/Context-Map) 설계

**Event-Storming이란<br/>**
: 서비스와 관계 있는 모든 이해관계자들이 서로가 가지고 있는 생각을 공유하며 서비스에서 발생하는 이벤트를 중심(Event-First)으로 분석하는 기법
<br/>

**Domain Devision Design<br/>**
: 도메인 패턴을 중심에 놓고 설계하는 방식<br/>

- 도메인 그 자체와 도메인 로직에 초점을 맞춘다. 일반적으로 많이 사용하는 데이터 중심의 접근법을 탈피해서 순수한 도메인의 모델과 로직에 집중하는 것
- 보편적인(ubiquitous) 언어의 사용. 도메인 전문가와 소프트웨어 개발자 간의 커뮤니케이션 문제를 없애고 상호가 이해할 수 있고 모든 문서와 코드에 이르기까지 동일한 표현과 단어로 구성된 단일화된 언어체계를 구축해나가는 과정. 이로서 분석 작업과 설계 그리고 구현에 이르기까지 통일된 방식으로 커뮤니케이션이 가능해짐.
- 소프트웨어 엔티티와 도메인 컨셉트를 가능한 가장 가까이 일치시킴. 분석 모델과 설계가 다르고 그것과 코드가 다른 구조가 아니라 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향하는 것이 DDD의 핵심원리.

1. Domain Event
: 발생하는 모든 이벤트(도메인 내 변경의 파생 작업)

2. External System
: 외부 시스템(외부 Api)

3. Command
: 각 도메인 이벤트를 발생시키는 명령

4. Hot Spot
: DDD 설계 중 추후에 논의할 점(해결될 경우에 탈착)

5. Actor
: 이벤트의 주체

6. Aggregate
: Command 수행을 위해 CRUD해야 하는 데이터 객체 정의

7. Policy
: 정책(서비스할 기능)

<details>
<summary><b>DDD 설계 과정</b></summary>

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd1.png">
</div>

1-1. Domain 작성
 
<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd2.png">
</div>

2-1. Command → Domain Event를 기반으로 작성 (명사형)<br/>
2-2. 각 Domain Event를 발생시키는 명령<br/>
2-3. 하나의 Command에 2개 이상의 Domain Event 가능<br/>
2-4. 비슷한 기능들의 Domain Event들끼리 가까운 위치에 추가<br/>

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd3.png">
</div>

3-1. Actor → 회원 또는 관리자로 분리<br/>
3-2. Domain Event를 기준으로 일반 회원 → 그룹장, 그룹원 등 세부화<br/>
3-3. Actor → 하나의 Command에 두 명 이상인 경우 有<br/>

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd4.png">
</div>

4-1. Command 수행을 위해 CRUD 해야 하는 데이터 객체 정의<br/>
4-2. 작성할 때는 Command가 수행되었을 때 변경되는 데이터 고려해 Aggregate 작성<br/>
4-3. 장소 별점 관련 Policy 추가<br/>
4-4. 고도화 고려 및 장소 등록 관련 추가 메모 작성<br/>

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd5.png">
</div>

5-1. 정책 추가<br/>
5-2. 메모 추가(기능의 정확한 정의, 고도화 가능성)<br/>

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd6.png">
</div>

6-1. 게시글 / 게시글(부가기능) / 게시글 댓글 / 장소 / 회원 / 그룹 / 계정 정보<br/>
6-2. Domain으로 분리<br/>

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd7.png">
</div>

7-1. Boundary(경계): 각 도메인 모델의 경계를 정의함. 이는 모델이 관리하는 데이터와 비즈니스 규칙을 나타냄.<br/>
7-2. Relationships(관계): 다른 도메인 모델과의 관계를 정의함. 이는 모델 간에 어떤 종류의 통신이 필요한지를 보여줌.<br/>
7-3. Shared Kernel(공유 커널): 두 개 이상의 도메인 모델 간에 공유되는 부분을 나타냄. 이는 각 모델이 특정 비즈니스 기능을 수행하는 데 필요한 공통 요소를 나타냄.<br/>
7-4. Customer/Supplier Relationships(고객/공급자 관계): 서로 다른 도메인 모델 간에 발생하는 요청과 응답의 흐름을 나타냄. 이는 서로 다른 모델 간에 어떤 종류의 통신이 이루어지는지를 보여줌.<br/>
<br/>
***7-5. 위의 4가지를 고려해서 Context Mapping<br/>***

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/ddd8.png">
</div>

8-1. Root 설정 후 중간객체 생성<br/>
8-2. 정책 재설정

</details>
<br/>

<strong>* Context Map</strong>

<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/d674c62d4db5c1a6e0f6d8234bc6c7aea9384b24/PNG/contextmap.png">
</div>

- 핵심 기능 우선 구현
- Root간 1:N, 1:1 관계 설정

## 모델링

### 1. 개념 모델링

### 2. 논리 모델링

### 3. 물리 모델링

### ERD Cloud 활용

## DDL
<details>
<summary><b>DDL</b></summary>
    
```
CREATE TABLE `member_info` (
	`member_id`	INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `member_email`   VARCHAR(127)   NOT NULL UNIQUE,
   `password`   VARCHAR(255)   NOT NULL,
   `member_name`   VARCHAR(63)   NOT NULL,
   `member_nickname`   VARCHAR(31)   NOT NULL UNIQUE,
   `member_number`   VARCHAR(15)   NOT NULL,
   `join_date`   VARCHAR(255)   NOT NULL,
   `withdrawal_date`   VARCHAR(255)   NULL,
   `member_grade`   ENUM('ROLL_MEMBER', 'ROLL_ADMIN')   NOT NULL,
   `member_status`  CHAR(1) NOT NULL    DEFAULT 'Y'
);

CREATE TABLE `post` (
   `post_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `post_title`   VARCHAR(255)   NOT NULL,
   `post_content`   VARCHAR(255)   NOT NULL,
   `post_date`   VARCHAR(255)   NOT NULL,
   `post_delete_date`   VARCHAR(255)   NULL,
   `member_id`   INT   NOT NULL,
   `course_id`   INT   NOT NULL,
   `is_post_public`   CHAR(1) NOT NULL    DEFAULT 'Y',
   `member_count`   ENUM('ONE', 'TWO', 'MANY')   NOT NULL
);

CREATE TABLE `plrecipe_group` (
   `group_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `group_name`   VARCHAR(255)   NOT NULL,
   `is_group_public`   CHAR(1) NOT NULL    DEFAULT 'Y',
   `group_create_date`   VARCHAR(255)   NOT NULL,
   `group_withdrawal_date` VARCHAR(255) NULL,
   `group_comment`   VARCHAR(255)   NULL,
   `group_status`  CHAR(1) NOT NULL    DEFAULT 'Y'
);

CREATE TABLE `follow_info` (
   `follow_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `user_follow`   INT   NOT NULL,
   `user_follower`  INT   NOT NULL
);

CREATE TABLE `place_star` (
   `star_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `star_point`   INT   NOT NULL,
   `star_comment`   VARCHAR(255)   NULL,
   `place_id`   INT   NOT NULL,
   `member_id`   INT   NOT NULL
);

CREATE TABLE `place` (
   `place_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `place_name`   VARCHAR(127)   NOT NULL,
   `place_location`   VARCHAR(255)   NOT NULL,
   `place_phone_num`   VARCHAR(15)   NULL,
   `place_category_id`   INT   NOT NULL
);

CREATE TABLE `image` (
   `image_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `image_location`   VARCHAR(255)   NOT NULL,
   `image_name`   VARCHAR(255)   NOT NULL,
   `post_id`   INT   NOT NULL,
   `member_id`   INT   NOT NULL,
   `group_id`   INT   NOT NULL,
   `image_rename`   VARCHAR(255)   NULL
);

CREATE TABLE `course` (
   `course_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `course_name`   VARCHAR(127)   NULL,
   `member_id`   INT   NOT NULL
);

CREATE TABLE `group_member` (
   `group_member_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `groupmember_sequence`   INT   NOT NULL,
   `invite_state_id`   ENUM('ACCEPT', 'WAITING', 'DENY')   NOT NULL,
   `group_id`   INT   NOT NULL,
   `member_id`   INT NOT NULL
);

CREATE TABLE `course_place` (
   `place_course_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `place_id`   INT   NOT NULL,
   `course_id`   INT   NOT NULL,
   `place_sequence`   INT   NOT NULL
);

CREATE TABLE `place_category` (
   `place_category_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `place_category_name`   VARCHAR(63)   NOT NULL
);

CREATE TABLE `hashtag` (
   `hashtag_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `hashtag_title`   VARCHAR(255)   NOT NULL
);

CREATE TABLE `post_hashtag` (
   `post_hashtag_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `hashtag_id`   INT   NOT NULL,
   `post_id`   INT   NOT NULL
);

CREATE TABLE `post_like` (
   `post_like_id`   INT   NOT NULL AUTO_INCREMENT PRIMARY KEY,
   `member_id`   INT   NOT NULL,
   `post_id`   INT   NOT NULL
);

-- ALTER TABLE `member_info` ADD CONSTRAINT `PK_MEMBER_INFO` PRIMARY KEY (
--    `member_id`
-- );


ALTER TABLE `post` ADD CONSTRAINT `FK_member_info_TO_post_1` FOREIGN KEY (
   `member_id`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `post` ADD CONSTRAINT `FK_course_TO_post_1` FOREIGN KEY (
   `course_id`
)
REFERENCES `course` (
   `course_id`
);

ALTER TABLE `follow_info` ADD CONSTRAINT `FK_member_info_TO_follow_info_1` FOREIGN KEY (
   `user_follow`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `follow_info` ADD CONSTRAINT `FK_member_info_TO_follow_info_2` FOREIGN KEY (
   `user_follower`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `place_star` ADD CONSTRAINT `FK_place_TO_place_star_1` FOREIGN KEY (
   `place_id`
)
REFERENCES `place` (
   `place_id`
);

ALTER TABLE `place_star` ADD CONSTRAINT `FK_member_info_TO_place_star_1` FOREIGN KEY (
   `member_id`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `place` ADD CONSTRAINT `FK_place_category_TO_place_1` FOREIGN KEY (
   `place_category_id`
)
REFERENCES `place_category` (
   `place_category_id`
);


ALTER TABLE `image` ADD CONSTRAINT `FK_post_TO_image_1` FOREIGN KEY (
   `post_id`
)
REFERENCES `post` (
   `post_id`
);

ALTER TABLE `image` ADD CONSTRAINT `FK_member_info_TO_image_1` FOREIGN KEY (
   `member_id`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `image` ADD CONSTRAINT `FK_plrecipe_group_TO_image_1` FOREIGN KEY (
   `group_id`
)
REFERENCES `plrecipe_group` (
   `group_id`
);

ALTER TABLE `course` ADD CONSTRAINT `FK_member_info_TO_course_1` FOREIGN KEY (
   `member_id`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `group_member` ADD CONSTRAINT `FK_plrecipe_group_TO_group_member_1` FOREIGN KEY (
   `group_id`
)
REFERENCES `plrecipe_group` (
   `group_id`
);

ALTER TABLE `group_member` ADD CONSTRAINT `FK_member_info_TO_group_member_1` FOREIGN KEY (
   `member_id`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `course_place` ADD CONSTRAINT `FK_place_TO_course_place_1` FOREIGN KEY (
   `place_id`
)
REFERENCES `place` (
   `place_id`
);

ALTER TABLE `course_place` ADD CONSTRAINT `FK_course_TO_course_place_1` FOREIGN KEY (
   `course_id`
)
REFERENCES `course` (
   `course_id`
);

ALTER TABLE `post_hashtag` ADD CONSTRAINT `FK_hashtag_TO_post_hashtag_1` FOREIGN KEY (
   `hashtag_id`
)
REFERENCES `hashtag` (
   `hashtag_id`
);

ALTER TABLE `post_hashtag` ADD CONSTRAINT `FK_post_TO_post_hashtag_1` FOREIGN KEY (
   `post_id`
)
REFERENCES `post` (
   `post_id`
);

ALTER TABLE `post_like` ADD CONSTRAINT `FK_member_info_TO_post_like_1` FOREIGN KEY (
   `member_id`
)
REFERENCES `member_info` (
   `member_id`
);

ALTER TABLE `post_like` ADD CONSTRAINT `FK_post_TO_post_like_1` FOREIGN KEY (
   `post_id`
)
REFERENCES `post` (
   `post_id`
);
```

</details>


## Project Architecture(프로젝트 아키텍처)
### Monolith Architecture(모놀리스 아키텍처)
<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/637599a4f5d49fde05fffae4919f2709a826839a/PNG/monolith_image.png" height=250>
</div>
<br/>

- 다양한 서비스들이 '애플리케이션' 하나에 전부 모여있음
- 각 서비스 실행할 경우 하나로 모여있는 서버로 요청
- 서버에서 요청을 처리

**1. Monolith Architecture의 장점**

&nbsp;&nbsp;a. 간단한 배포 방식

&nbsp;&nbsp;b. 개발 워크플로우 용이

&nbsp;&nbsp;c. 테스트 단순화

&nbsp;&nbsp;d. 코드의 재사용 용이

**2. Monolith Architecture의 단점** 

&nbsp;&nbsp;a. 높은 결합도 - 혼란스로운 경계선(소유권)

&nbsp;&nbsp;b. 혼란스로운 경계선(소유권)


### MicroService Architecture(마이크로 서비스 아키텍처)
<div align="center">
<img src="https://github.com/6candoit/Plrecipe/blob/637599a4f5d49fde05fffae4919f2709a826839a/PNG/microservice_image.png" height=250>
</div>
<br/>

- 비즈니스 도메인을 기준으로 독립적으로 구성된 서비스
- 서비스들은 독립적인 배포가 가능
- 서비스들은 네트워크를 통해 서로 통신
- 서비스별로 데이터베이스 소유

***1-1. 마이크로 서비스의 장점***

- 독립적인 특성으로 인해 확장성, 견고성

- 개발시 서비스(업무) 별로 방해받지 않고 자신의 업무에 집중할 수 있음

- 언어, 플랫폼, 데이터베이스 등 종류에 상관없이 조합 가능

***1-2. 마이크로 서비스의 단점***

- 다수의 네트워크 통신으로 예측이 힘들고 패킷 손실이 야기될 수 있음

- 서비스를 분산할 수로 높은 비용, 시스템의 복잡도 상승, 고도의 기술이 필요

***1-3. 사용자 인터페이스***

- 마이크로 서비스를 사용 시 UI도 고려해야 됨

***1-4. 기술***

- 장점중 하나인 [언어, 플랫폼, 데이터베이스 등 종류에 상관없이 조합 가능]과 같이 기술의 제한 없이 구축 가능

***2 결합도와 응집력***

마이크로 서비스 아키텍처의 가장 중요한 요소는 결합도와 응집력.(응집력 높고 결합도 낮은게 안정적)

2-1. 응집력(Cohesion)

- 관련된 것끼리 묶인것

- 변경시 함께 바뀜

2-2. 결합도(Coupling)

- 다른 것과 연관된 것

- 결합된 서비스 전체를 신경 써야 됨

- 정보은닉 필요

- 결합도 종류
- 구현 결합도 : 데이터베이스를 공유<br/>
- 시간적 결합도 : 동기, 비동기 등 호출 실행 시간에 관련된 결합도<br/>
- 배포 결합도 : 모놀리스 형식이기 때문에 배포 시 모든 것을 함께 배포<br/>
- 도메인 결합도 : 서비스 도메인 간의 연결<br/>

### 프로젝트 아키텍처

<div align="center">
 <img src="https://github.com/6candoit/Plrecipe/blob/5fc203e0989f0f13a5a119b9e1f75cd48b280bce/PNG/plrecipe_architecture_test1.drawio1.png" height=320>
</div>
<br/>

아키텍처를 구성하기 위해 신경써야할 요소
1. 장애를 감안한 설계
2. 모든 계층의 보안
3. 다양한 스토리지 활용
4. 유연한 구조
5. 병렬 처리
6. 느슨한 결합
7. 새로운 시도

<div align="center">
 <img src="https://github.com/6candoit/Plrecipe/blob/5fc203e0989f0f13a5a119b9e1f75cd48b280bce/PNG/plrecipe_architecture_test1.drawio2.png" height=500>
</div>

- 유레카 서버와 유레카 클라이언트로 구성됨
- 유저는 게이트웨이를 통해 원하는 서비스와 매칭됨(Member, Group, Post, Place)
- 비밀번호 암호화 및 로그인 인증을 구현함(Spring Security 6 version 활용)
- 로그인 시, 토큰을 발급받아 이후 인증이 필요한 서비스에 접근 가능함(JWT(java web token) 활용)
- 장소 서비스는 API를 통해 장소 정보를 받아옴(외부 Api는 Kakaomap api 사용)
- 각 서비스끼리 통신하여 필요한 정보를 주고 받음
- (현재 DB는 하나의 DB를 사용함)

## Eureka Server
<p align="center"><img src="https://github.com/6candoit/Plrecipe/blob/3127aa3c06426140eb0887869201fe4d40b9a96f/PNG/eurekaserver.png" height=350></p>

&nbsp;Eureka 서버는 마이크로서비스 아키텍처에서 사용되는 서비스 디스커버리 및 로드 밸런싱 도구 중 하나입니다. Netflix에서 개발한 Eureka는 클라우드 환경에서 동적으로 변하는 서비스 인스턴스를 관리하고, 이를 검색할 수 있는 기능을 제공합니다.

&nbsp;기본적으로 Eureka는 클라이언트-서버 아키텍처를 따릅니다. Eureka 서버는 서비스 레지스트리의 역할을 하며, 서비스 인스턴스들이 등록되고 각 서비스 인스턴스의 상태를 추적합니다. 클라이언트는 Eureka 서버에 자신의 위치를 등록하고, 다른 서비스 인스턴스들의 위치를 검색할 수 있습니다.

### Eureka Server 기능

1. 서비스 등록: 서비스 인스턴스가 시작될 때, 해당 서비스를 Eureka 서버에 등록.

2. 서비스 검색: 클라이언트 애플리케이션이 다른 서비스 인스턴스의 위치를 검색. 이를 통해 클라이언트는 동적으로 서비스 위치를 찾아서 통신.

3. 서비스 상태 감시: Eureka는 등록된 서비스 인스턴스들의 상태를 주기적으로 감시하고, 문제가 발생한 인스턴스들을 자동으로 감지하고 제거함.

## API 개발 및 설계 도구
### Postman
<div align="center">
<figure class="half">
 <a href="link"><img src="https://github.com/6candoit/Plrecipe/blob/3dd1c6b7f23182f45d3cf3b08929bac89136b7e7/PNG/postman_image.png" height=130></a>
 <a href="link"><img src="https://github.com/6candoit/Plrecipe/blob/3dd1c6b7f23182f45d3cf3b08929bac89136b7e7/PNG/postman_image2.png" height=130></a>
</figure>
<img src="https://github.com/6candoit/Plrecipe/blob/3dd1c6b7f23182f45d3cf3b08929bac89136b7e7/PNG/postman_image3.png" height=365>
</div>
<br/>
<strong>API 개발 및 테스트를 위한 협업 도구로서, 다양한 기능을 제공하는 플랫폼</strong>

1. API 요청 및 응답 테스트: Postman을 사용하면 다양한 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 API 엔드포인트에 요청을 보낼 수 있고 헤더, 쿠키, 인증 등 다양한 요청 구성이 가능하며, 받은 응답을 쉽게 확인할 수 있음.

2. 환경 변수 및 변수 활용: Postman에서는 환경 변수를 사용하여 다양한 환경(개발, 테스트, 프로덕션 등)에 대한 설정을 저장하고, 이를 활용하여 요청을 보내거나 테스트를 실행 가능. 또한 변수를 사용하여 동적으로 요청을 생성 가능.

3. 테스트 스크립팅: Postman에서는 JavaScript를 사용하여 테스트 스크립트를 작성할 수 있음. 이를 통해 응답을 자동으로 검증하거나, 특정 조건에 따라 동작을 수행할 수 있음.

4. 콜렉션 및 폴더 관리: Postman은 API 요청을 관리하기 위한 콜렉션과 폴더를 제공. 이를 통해 관련된 요청을 그룹화하고 구조화.

5. 문서화 및 공유: Postman을 사용하여 API 요청을 문서화하고, 이를 공유함. 다른 팀원들과 협업하여 API에 대한 문서를 유지하고 업데이트할 수 있음.

6. 모니터링: Postman에서는 API의 성능을 모니터링하고 관리할 수 있는 기능도 제공.

### Swagger
<div align="center">
 <img src="https://github.com/6candoit/Plrecipe/blob/a627030605c9c3fc5ab29d1895da59c28b9c406e/PNG/swagger_image.png" height=150>
</div>
<br/>
<strong>RESTful API를 설계, 빌드, 문서화하기 위한 프레임워크. OpenAPI Specification의 일부로, API에 대한 자세한 문서를 제공하여 개발자들이 API를 쉽게 이해하고 사용가능하도록 함</strong>

1. API 설계: Swagger를 사용하여 API 엔드포인트, 매개변수, 헤더, 응답 형식 등을 정의. 이를 통해 API의 구조를 명확하게 정의하고 일관성 있게 유지함.

2. 문서 자동 생성: Swagger는 API의 구조를 기반으로 자동으로 API 문서를 생성. 이 문서에는 API의 엔드포인트, 매개변수, 응답 형식, 인증 방법 등에 대한 자세한 설명이 포함.

3. 인터랙티브 API 테스트: Swagger UI를 사용하면 API를 테스트할 수 있는 인터랙티브한 환경을 제공. 개발자들은 Swagger UI를 통해 API 엔드포인트를 호출하고 응답을 확인.

4. 클라이언트 코드 생성: Swagger를 사용하여 API에 대한 클라이언트 코드를 자동으로 생성. 이를 통해 개발자들은 API를 사용하는 클라이언트 애플리케이션을 쉽게 개발할 수 있음.

5. 인증 및 보안: Swagger를 사용하여 API에 대한 인증 및 보안 기능을 정의. 이를 통해 API를 보호하고 안전하게 사용할 수 있도록 함.

## 테스트


## 회고록
